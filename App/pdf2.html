<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="PageFlow: Your premium PDF library for viewing, creating, scanning, locking, unlocking, and sharing PDF documents.">
    <meta name="keywords" content="PDF, document, viewer, editor, create PDF, scan to PDF, lock PDF, unlock PDF, share PDF, PWA">
    <meta name="author" content="PageFlow Team">
    <title>PageFlow - Premium PDF Library</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="https://placehold.co/32x32/1a1a2e/ffffff?text=PF" type="image/png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 25%, #16213e 50%, #0f0f23 75%, #1a1a2e 100%);
            background-size: 400% 400%;
            animation: gradientShift 20s ease infinite;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            color: #fff;
            overflow-x: hidden;
            overscroll-behavior-y: contain;
        }
        @keyframes gradientShift {
            0% { background-position: 0% 50% }
            50% { background-position: 100% 50% }
            100% { background-position: 0% 50% }
        }
        .gradient-text {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientTextShift 8s ease infinite;
        }
        @keyframes gradientTextShift {
            0%, 100% { background-position: 0% 50% }
            50% { background-position: 100% 50% }
            100% { background-position: 0% 50% }
        }
        .glass {
            backdrop-filter: blur(20px);
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        .glass-hover {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .glass-hover:hover {
            backdrop-filter: blur(25px);
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(102, 126, 234, 0.3);
            box-shadow: 0 20px 60px rgba(102, 126, 234, 0.2);
            transform: translateY(-8px);
        }
        .card-float {
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .card-float:hover {
            transform: translateY(-12px) scale(1.02);
            box-shadow: 0 25px 80px rgba(102, 126, 234, 0.3), 0 0 40px rgba(118, 75, 162, 0.2);
        }
        .search-glass {
            backdrop-filter: blur(15px);
            background: rgba(255, 255, 255, 0.06);
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        .search-glass:focus {
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.3);
        }
        .page-canvas {
            transition: all 0.3s ease;
            cursor: pointer;
            width: 100%;
            height: auto;
            display: block;
        }
        .page-canvas:hover {
            transform: scale(1.01);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.4);
        }
        .thumbnail {
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }
        .thumbnail:hover {
            transform: scale(1.05);
            border-color: #667eea;
        }
        .thumbnail.active {
            border-color: #f093fb;
            box-shadow: 0 0 20px rgba(240, 147, 251, 0.5);
        }
        .modal-overlay {
            backdrop-filter: blur(10px);
            background: rgba(0, 0, 0, 0.9);
        }
        .zoom-controls {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }
        .scrollbar-custom::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        .scrollbar-custom::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        .scrollbar-custom::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 10px;
        }
        .scrollbar-custom::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #764ba2, #f093fb);
        }
        .pulse-dot {
            width: 8px;
            height: 8px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1 }
            50% { transform: scale(1.2); opacity: 0.8 }
        }
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(102, 126, 234, 0.2);
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg) }
            100% { transform: rotate(360deg) }
        }
        .fade-in {
            animation: fadeIn 0.8s ease-out forwards;
        }
        .fade-in-delay {
            animation: fadeIn 0.8s ease-out 0.3s forwards;
            opacity: 0;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(30px) }
            to { opacity: 1; transform: translateY(0) }
        }
        .slide-up {
            animation: slideUp 0.4s ease-out;
        }
        @keyframes slideUp {
            from { transform: translateY(100px); opacity: 0 }
            to { transform: translateY(0); opacity: 1 }
        }
        .category-badge {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
            border: 1px solid rgba(102, 126, 234, 0.3);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        #notificationContainer {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-width: 90%;
        }
        .notification {
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            color: #fff;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            animation: slideInRight 0.3s ease-out forwards;
            cursor: pointer;
        }
        .notification.success { background-color: #28a745; }
        .notification.error { background-color: #dc3545; }
        .notification.info { background-color: #007bff; }
        .notification.warning { background-color: #ffc107; }
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .notification.slide-out {
            animation: slideOutRight 0.3s ease-in forwards;
        }
        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        .password-modal {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }
        .password-modal-content {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }
        #pdfContainer {
            max-width: 1280px;
            width: 100%;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 1rem;
        }
        #presentationModal {
            background-color: black;
            z-index: 60;
        }
        #presentationPageContainer {
            position: relative;
            width: 100%;
            height: calc(100% - 100px);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        #presentationCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
            z-index: 10;
        }
        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            z-index: 20;
            cursor: none;
        }
        .presentation-nav-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: white;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.3s ease;
            z-index: 30;
        }
        .presentation-nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-50%) scale(1.1);
        }
        #prevPresentationPageBtn { left: 1rem; }
        #nextPresentationPageBtn { right: 1rem; }
        #presentationThumbnailContainer {
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 1rem;
            overflow-x: auto;
            white-space: nowrap;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        #presentationThumbnailContainer::-webkit-scrollbar {
            display: none;
        }
        .presentation-thumbnail {
            height: 80px;
            width: auto;
            object-fit: contain;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s ease, transform 0.2s ease;
            margin: 0 5px;
        }
        .presentation-thumbnail.active {
            border-color: #f093fb;
            transform: scale(1.05);
        }
        .action-button {
            background: linear-gradient(135deg, #007bff 0%, #00c6ff 100%);
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 123, 255, 0.3);
        }
        .action-button:hover {
            background: linear-gradient(135deg, #0056b3 0%, #0099cc 100%);
            box-shadow: 0 6px 15px rgba(0, 123, 255, 0.5);
            transform: translateY(-2px);
        }
        .image-preview-item {
            position: relative;
            width: 100px;
            height: 100px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.3);
            padding-top: 15px;
        }
        .image-preview-item .image-number {
            position: absolute;
            top: 2px;
            left: 5px;
            font-size: 0.75rem;
            font-weight: bold;
            color: #f093fb;
            z-index: 1;
        }
        .image-preview-item img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .image-preview-item .remove-image-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .image-preview-item .remove-image-btn:hover {
            background-color: rgba(255, 0, 0, 1);
        }
        #scanToPdfScreen {
            background-color: #000;
        }
        #cameraFeedContainer {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            aspect-ratio: 16/9;
            background-color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-radius: 12px;
        }
        #videoFeed {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        #flashOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0);
            transition: background-color 0.1s ease-out;
            z-index: 5;
            pointer-events: none;
        }
        #flashOverlay.active {
            background-color: rgba(255, 255, 255, 0.8);
        }
        .camera-control-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: white;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .camera-control-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.05);
        }
        #captureButton {
            width: 70px;
            height: 70px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: 5px solid rgba(255, 255, 255, 0.4);
            transition: all 0.2s ease;
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }
        #captureButton:hover {
            background: linear-gradient(45deg, #764ba2, #f093fb);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.05);
        }
        #imageCapturePreviews {
            max-height: 120px;
            overflow-x: auto;
            white-space: nowrap;
            padding: 10px 0;
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        #imageCapturePreviews::-webkit-scrollbar {
            display: none;
        }
        .captured-image-item {
            position: relative;
            width: 100px;
            height: 100px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            overflow: hidden;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.5);
        }
        .captured-image-item img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .captured-image-item .image-number {
            position: absolute;
            top: 4px;
            left: 6px;
            font-size: 0.7rem;
            font-weight: bold;
            color: #f093fb;
            background-color: rgba(0,0,0,0.6);
            border-radius: 4px;
            padding: 2px 5px;
        }
        .captured-image-item .remove-captured-image-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .captured-image-item .remove-captured-image-btn:hover {
            background-color: rgba(255, 0, 0, 1);
        }
        .tool-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            min-height: 180px;
        }
        .tool-card i {
            font-size: 3.5rem;
            margin-bottom: 1rem;
            color: #a78bfa;
        }
        .tool-card h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #fff;
        }
        #bottomNavBar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(15px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
            display: flex;
            justify-content: space-around;
            padding: 0.75rem 0;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.4);
        }
        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #fff;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 0.5rem;
            border-radius: 0.5rem;
        }
        .nav-item i {
            font-size: 1.5rem;
            margin-bottom: 0.25rem;
            transition: color 0.3s ease;
        }
        .nav-item.active {
            color: #f093fb;
            background: rgba(255, 255, 255, 0.1);
        }
        .nav-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #a78bfa;
        }
        .nav-item.active i {
            color: #f093fb;
        }
        #mainHeader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 90;
        }
        .content-padded {
            padding-top: 100px;
            padding-bottom: 80px;
        }
        .hide-on-non-main-screens {
            display: none !important;
        }
        /* Removed #colorPickerContainer and .color-swatch CSS */
        @media (max-width: 640px) {
            .mobile-hidden { display: none; }
            .mobile-full { width: 100%; }
            .mobile-text-sm { font-size: 0.875rem; }
            .mobile-grid { grid-template-columns: 1fr; }
            .mobile-p-2 { padding: 0.5rem; }
            #notificationContainer {
                top: 0.5rem;
                right: 0.5rem;
                left: 0.5rem;
                max-width: unset;
            }
            #pdfContainer {
                max-width: 100%;
                max-height: calc(100vh - 180px);
            }
            .action-button {
                padding: 0.6rem 1rem;
                font-size: 0.875rem;
            }
            .presentation-nav-btn {
                width: 40px;
                height: 40px;
                font-size: 1.2rem;
            }
            #prevPresentationPageBtn { left: 0.5rem; }
            #nextPresentationPageBtn { right: 0.5rem; }
            #presentationThumbnailContainer {
                height: 80px;
                padding: 0 0.5rem;
            }
            .presentation-thumbnail {
                height: 60px;
            }
            #mergePdfInput + span {
                display: none;
            }
            .camera-control-btn {
                width: 45px;
                height: 45px;
                font-size: 1rem;
            }
            #captureButton {
                width: 60px;
                height: 60px;
                border-width: 4px;
            }
            #cameraControlsTop {
                padding: 0.5rem;
            }
            #cameraControlsBottom {
                padding: 0.5rem;
            }
            .tool-card {
                padding: 1.5rem;
                min-height: 150px;
            }
            .tool-card i {
                font-size: 3rem;
            }
            .tool-card h3 {
                font-size: 1rem;
            }
            #bottomNavBar {
                padding: 0.5rem 0;
            }
            .nav-item i {
                font-size: 1.2rem;
            }
            .content-padded {
                padding-top: 80px;
                padding-bottom: 70px;
            }
            /* Removed #colorPickerContainer media query adjustments */
        }
        @media (min-width: 641px) and (max-width: 1024px) {
            .tablet-grid { grid-template-columns: repeat(2, 1fr); }
            .tablet-p-4 { padding: 1rem; }
            #pdfContainer {
                max-width: 768px;
            }
            /* Removed #colorPickerContainer media query adjustments */
        }
        @media (min-width: 1025px) {
            .desktop-grid { grid-template-columns: repeat(3, 1fr); }
            .desktop-p-6 { padding: 1.5rem; }
            #pdfContainer {
                max-width: 1280px;
            }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">
    <div id="mainHeader" class="glass p-4 md:p-6">
        <div class="max-w-7xl mx-auto">
            <div class="flex items-center justify-between mb-6">
                <h1 class="text-3xl md:text-5xl font-bold gradient-text">PageFlow</h1>
                <div class="flex items-center space-x-3">
                    <div class="pulse-dot"></div>
                    <span class="text-sm text-gray-400">Premium PDF Library</span>
                </div>
            </div>
        </div>
    </div>
    <div id="toolsScreen" class="flex-grow content-padded overflow-y-auto scrollbar-custom">
        <div class="max-w-7xl mx-auto p-4 md:p-6">
            <h2 class="text-2xl font-semibold text-gray-300 mb-6">Tools</h2>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 md:gap-8 mb-8">
                <label for="fileUpload" class="tool-card glass glass-hover rounded-2xl fade-in">
                    <i class="fas fa-upload"></i>
                    <h3>Upload PDF</h3>
                    <input type="file" id="fileUpload" accept="application/pdf" class="hidden">
                </label>
                <div id="openCreatePdfModalBtn" class="tool-card glass glass-hover rounded-2xl fade-in">
                    <i class="fas fa-images"></i>
                    <h3>Create PDF from Images</h3>
                </div>
                <div id="openScanToPdfScreenBtn" class="tool-card glass glass-hover rounded-2xl fade-in">
                    <i class="fas fa-camera"></i>
                    <h3>Scan to PDF</h3>
                </div>
            </div>
        </div>
    </div>
    <div id="filesScreen" class="flex-grow content-padded overflow-y-auto scrollbar-custom hidden">
        <div class="max-w-7xl mx-auto p-4 md:p-6">
            <div class="relative max-w-2xl mx-auto mb-8">
                <div class="absolute left-4 top-1/2 transform -translate-y-1/2 text-gray-400">
                    <i class="fas fa-search text-lg"></i>
                </div>
                <input type="text" id="searchInput" placeholder="Search documents by title, category, or content..."
                       class="w-full pl-12 pr-4 py-4 search-glass rounded-2xl text-white placeholder-gray-400 text-lg focus:outline-none">
                <div class="absolute right-4 top-1/2 transform -translate-y-1/2 mobile-hidden">
                    <kbd class="px-2 py-1 text-xs bg-gray-700 rounded">⌘K</kbd>
                </div>
            </div>
            <div class="mb-8">
                <h2 class="text-2xl font-semibold text-gray-300 mb-4">Recently Opened</h2>
                <div id="historyGrid" class="grid mobile-grid tablet-grid desktop-grid gap-6 md:gap-8">
                    <div id="noHistory" class="col-span-full text-center py-10 text-gray-500">
                        No recently opened PDFs. Open one to see it here!
                    </div>
                </div>
            </div>
            <div class="mb-8">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-2xl font-semibold text-gray-300">Your Documents</h2>
                    <div class="flex items-center space-x-4 text-sm text-gray-400">
                        <span id="totalDocs">0 documents</span>
                        <span id="searchResults" class="hidden"></span>
                    </div>
                </div>
            </div>
            <div id="pdfGrid" class="grid mobile-grid tablet-grid desktop-grid gap-6 md:gap-8">
            </div>
            <div id="noResults" class="hidden text-center py-20">
                <div class="text-6xl text-gray-600 mb-4"><i class="fas fa-search"></i></div>
                <h3 class="text-xl text-gray-400 mb-2">No documents found</h3>
                <p class="text-gray-500">Try adjusting your search terms or upload a new PDF.</p>
            </div>
        </div>
    </div>
    <div id="pdfViewer" class="min-h-screen hidden flex flex-col">
        <div class="glass p-4 sticky top-0 z-40">
            <div class="flex items-center justify-between">
                <button id="backBtn" class="text-white hover:text-purple-400 transition-colors p-2 rounded-lg hover:bg-gray-700" title="Back to Library">
                    <i class="fas fa-arrow-left text-xl"></i>
                </button>
                <div class="flex-1 mx-4 min-w-0 overflow-x-auto whitespace-nowrap scrollbar-custom">
                    <h2 id="pdfTitle" class="text-lg md:text-xl font-semibold truncate gradient-text inline-block"></h2>
                    <p id="pdfCategory" class="text-sm text-gray-400 mt-1 inline-block ml-2"></p>
                </div>
                <div class="flex items-center space-x-2 md:space-x-4">
                    <!-- Removed Merge PDF, Share, and Download buttons -->
                    <button id="openPresentationBtn" class="p-2 hover:bg-gray-700 rounded transition-colors" title="Open Presentation Mode">
                        <i class="fas fa-play"></i>
                    </button>
                    <div class="flex items-center space-x-2 mobile-hidden">
                        <span class="text-sm text-gray-300">Page:</span>
                        <input type="number" id="pageInput" class="w-16 px-2 py-1 bg-gray-800 rounded text-white text-sm" min="1">
                        <button id="goToPage" class="px-3 py-1 bg-purple-600 hover:bg-purple-700 rounded text-sm transition-colors">Go</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="flex-1 p-4 flex justify-center items-start">
            <div id="pdfContainer" class="max-w-4xl w-full scrollbar-custom">
                <div id="loadingSpinner" class="flex items-center justify-center py-20">
                    <div class="loading-spinner"></div>
                </div>
                <div id="pdfPages" class="space-y-6">
                </div>
            </div>
        </div>
        <div class="glass p-4 sticky bottom-0">
            <div class="flex items-center justify-center space-x-4">
                <button id="prevPage" class="p-2 hover:bg-gray-700 rounded transition-colors" title="Previous Page">
                    <i class="fas fa-chevron-left"></i>
                </button>
                <div id="thumbnailContainer" class="flex space-x-2 overflow-x-auto scrollbar-custom" style="max-width:calc(100vw - 200px)">
                </div>
                <button id="nextPage" class="p-2 hover:bg-gray-700 rounded transition-colors" title="Next Page">
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
        </div>
    </div>
    <div id="pageModal" class="fixed inset-0 z-50 hidden">
        <div class="modal-overlay absolute inset-0"></div>
        <div class="relative h-full flex items-center justify-center p-4">
            <div class="zoom-controls absolute top-4 left-4 z-10 rounded-lg p-2 flex space-x-2">
                <button id="zoomIn" class="p-2 text-white hover:bg-gray-600 rounded transition-colors" title="Zoom In">
                    <i class="fas fa-search-plus"></i>
                </button>
                <button id="zoomOut" class="p-2 text-white hover:bg-gray-600 rounded transition-colors" title="Zoom Out">
                    <i class="fas fa-search-minus"></i>
                </button>
                <button id="resetZoom" class="p-2 text-white hover:bg-gray-600 rounded transition-colors" title="Reset Zoom">
                    <i class="fas fa-expand-arrows-alt"></i>
                </button>
            </div>
            <button id="closeModal" class="absolute top-4 right-4 z-10 p-2 text-white hover:bg-gray-600 rounded transition-colors" title="Close">
                <i class="fas fa-times text-xl"></i>
            </button>
            <div id="modalContent" class="max-w-full max-h-full overflow-auto">
                <canvas id="modalCanvas" class="max-w-full max-h-full"></canvas>
            </div>
        </div>
    </div>

    <div id="presentationModal" class="fixed inset-0 hidden flex flex-col">
        <div id="presentationPageContainer" class="flex-1 relative">
            <canvas id="presentationCanvas"></canvas>
            <canvas id="drawingCanvas"></canvas>
            <button id="prevPresentationPageBtn" class="presentation-nav-btn">
                <i class="fas fa-chevron-left"></i>
            </button>
            <button id="nextPresentationPageBtn" class="presentation-nav-btn">
                <i class="fas fa-chevron-right"></i>
            </button>
            <button id="closePresentationBtn" class="absolute top-4 right-4 z-30 p-2 text-white hover:bg-gray-600 rounded transition-colors" title="Close Presentation">
                <i class="fas fa-times text-xl"></i>
            </button>
            <button id="toggleAutoplayBtn" class="absolute top-4 left-20 z-30 p-2 text-white hover:bg-gray-600 rounded transition-colors" title="Toggle Autoplay">
                <i class="fas fa-play"></i>
            </button>
            <button id="togglePointerBtn" class="absolute top-4 left-40 z-30 p-2 text-white hover:bg-gray-600 rounded transition-colors" title="Toggle Pointer">
                <i class="fas fa-hand-pointer"></i>
            </button>
            <button id="togglePenBtn" class="absolute top-4 left-60 z-30 p-2 text-white hover:bg-gray-600 rounded transition-colors" title="Toggle Pen">
                <i class="fas fa-pen"></i>
            </button>
            <!-- Removed colorPickerContainer -->
        </div>
        <div id="presentationThumbnailContainer" class="scrollbar-custom">
        </div>
    </div>
    <div id="createPdfScreen" class="min-h-screen hidden flex flex-col">
        <div class="glass p-4 sticky top-0 z-40">
            <div class="flex items-center justify-between">
                <button id="backToMainFromCreatePdfBtn" class="text-white hover:text-purple-400 transition-colors p-2 rounded-lg hover:bg-gray-700" title="Back to Library">
                    <i class="fas fa-arrow-left text-xl"></i>
                </button>
                <h2 class="text-lg md:text-xl font-semibold truncate gradient-text flex-1 text-center">Create PDF from Images</h2>
                <div class="w-10"></div>
            </div>
        </div>
        <div class="flex-1 p-4 flex justify-center items-start overflow-y-auto scrollbar-custom">
            <div class="max-w-2xl w-full glass rounded-2xl p-8 my-8">
                <p class="text-gray-300 mb-6 text-center">Select multiple images to combine them into a single PDF document.</p>
                <div class="mb-4">
                    <label for="imageUploadInput" class="action-button w-full mb-4">
                        <i class="fas fa-plus-circle mr-2"></i> Add Images
                        <input type="file" id="imageUploadInput" accept="image/jpeg, image/png, image/webp" multiple class="hidden">
                    </label>
                </div>
                <div id="imagePreviews" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 mb-6 max-h-60 overflow-y-auto scrollbar-custom">
                    <div id="noImageSelected" class="col-span-full text-center text-gray-500 py-4 hidden">
                        No images selected yet.
                    </div>
                </div>
                <div class="mb-6">
                    <label for="newPdfNameInput" class="block text-gray-300 text-sm font-medium mb-2">PDF Name:</label>
                    <input type="text" id="newPdfNameInput" placeholder="My New Document"
                           class="w-full px-4 py-3 rounded-lg bg-gray-800 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-600">
                </div>
                <div class="flex flex-col sm:flex-row justify-end space-y-3 sm:space-y-0 sm:space-x-4">
                    <button id="cancelCreatePdfBtn" class="py-3 px-6 bg-gray-700 hover:bg-gray-600 rounded-lg transition-all duration-300 text-white font-semibold">
                        Cancel
                    </button>
                    <button id="createPdfFromImagesBtn" class="py-3 px-6 bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 rounded-lg transition-all duration-300 text-white font-semibold">
                        Create PDF
                    </button>
                </div>
            </div>
        </div>
    </div>
    <div id="scanToPdfScreen" class="min-h-screen hidden flex flex-col items-center justify-between p-4">
        <div id="cameraControlsTop" class="w-full max-w-2xl flex justify-between items-center z-10 py-4">
            <button id="backToMainFromScanBtn" class="camera-control-btn">
                <i class="fas fa-arrow-left"></i>
            </button>
            <button id="createPdfFromScanBtn" class="action-button px-4 py-2">
                <i class="fas fa-file-pdf mr-2"></i> Create PDF
            </button>
        </div>
        <div id="cameraFeedContainer" class="relative flex-grow flex items-center justify-center my-4">
            <video id="videoFeed" autoplay playsinline class="rounded-xl"></video>
            <canvas id="captureCanvas" class="hidden"></canvas>
            <div id="flashOverlay"></div>
            <div class="absolute top-4 left-4 flex flex-col space-y-3">
                <button id="toggleFlashBtn" class="camera-control-btn">
                    <i class="fas fa-flash"></i>
                </button>
                <button id="switchCameraBtn" class="camera-control-btn">
                    <i class="fas fa-camera-rotate"></i>
                </button>
            </div>
            <button id="captureButton" class="absolute bottom-4 rounded-full flex items-center justify-center">
                <i class="fas fa-camera text-2xl text-white"></i>
            </button>
        </div>
        <div id="imageCapturePreviews" class="w-full max-w-2xl glass rounded-xl py-2 px-4 mb-4 scrollbar-custom">
            <div id="noCapturedImages" class="text-center text-gray-500 py-4 hidden">
                No photos captured yet.
            </div>
        </div>
    </div>
    <div id="notificationContainer"></div>
    <div id="bottomNavBar">
        <div id="navTools" class="nav-item active">
            <i class="fas fa-tools"></i>
            <span>Tools</span>
        </div>
        <div id="navFiles" class="nav-item">
            <i class="fas fa-folder"></i>
            <span>Files</span>
        </div>
    </div>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        const { PDFDocument, rgb, StandardFonts } = PDFLib;
        function uint8ToBase64(uint8Array) {
            let binary = '';
            const len = uint8Array.byteLength;
            const chunkSize = 16384;
            for (let i = 0; i < len; i += chunkSize) {
                const chunk = uint8Array.subarray(i, Math.min(i + chunkSize, len));
                binary += String.fromCharCode.apply(null, chunk);
            }
            return btoa(binary);
        }
        function base64ToUint8(base64String) {
            return Uint8Array.from(atob(base64String), c => c.charCodeAt(0));
        }
        class NotificationManager {
            constructor() {
                this.container = document.getElementById('notificationContainer');
                if (!this.container) {
                    console.error('Notification container not found!');
                    return;
                }
            }
            show(message, type = 'info', duration = 3000) {
                const notificationElement = document.createElement('div');
                notificationElement.className = `notification ${type} rounded-xl shadow-lg`;
                notificationElement.innerHTML = `
                    <i class="fas ${this._getIcon(type)} text-xl"></i>
                    <span>${message}</span>
                `;
                this.container.appendChild(notificationElement);
                let timeoutId;
                const dismissNotification = () => {
                    notificationElement.classList.add('slide-out');
                    notificationElement.addEventListener('animationend', () => {
                        notificationElement.remove();
                    }, { once: true });
                    clearTimeout(timeoutId);
                };
                timeoutId = setTimeout(dismissNotification, duration);
                notificationElement.addEventListener('click', dismissNotification);
            }
            _getIcon(type) {
                switch (type) {
                    case 'success': return 'fa-check-circle';
                    case 'error': return 'fa-times-circle';
                    case 'info': return 'fa-info-circle';
                    case 'warning': return 'fa-exclamation-triangle';
                    default: return 'fa-info-circle';
                }
            }
            showSuccess(message, duration = 3000) {
                this.show(message, 'success', duration);
            }
            showError(message, duration = 5000) {
                this.show(message, 'error', duration);
            }
            showInfo(message, duration = 3000) {
                this.show(message, 'info', duration);
            }
        }
        class PageFlow {
            constructor() {
                this.notificationManager = new NotificationManager();
                this.pdfFiles = []; // Stores metadata for all PDFs
                this.filteredFiles = []; // For search results
                this.currentPdf = null; // Currently opened PDF object (includes data)
                this.currentPage = 1;
                this.totalPages = 0;
                this.zoomLevel = 1;
                this.pages = []; // Stores PDFPageProxy objects and their canvases for current PDF
                this.pdfDoc = null; // PDFDocumentProxy object for the current PDF
                this.currentPresentationPage = 1;
                this.autoplayIntervalId = null;
                this.isPointerActive = false;
                this.isPenActive = false;
                this.isDrawing = false;
                this.currentStroke = [];
                this.allPageDrawings = new Map(); // Stores drawings for each page
                this.penColors = ['#FFFF00', '#FF0000', '#00FF00', '#0000FF', '#FFFFFF', '#FFA500', '#800080', '#00FFFF']; // 8 colors
                this.penColorIndex = -1; // Start at -1, first click makes it 0 (yellow)
                this.penColor = this.penColors[0]; // Default pen color
                this.openedPdfHistory = []; // Stores metadata for recently opened PDFs
                this.imagesToPdf = []; // For Create PDF from Images
                this.cameraStream = null;
                this.facingMode = 'environment';
                this.capturedImages = []; // For Scan to PDF
                this.elements = {
                    mainHeader: document.getElementById('mainHeader'),
                    toolsScreen: document.getElementById('toolsScreen'),
                    filesScreen: document.getElementById('filesScreen'),
                    pdfViewer: document.getElementById('pdfViewer'),
                    searchInput: document.getElementById('searchInput'),
                    fileUpload: document.getElementById('fileUpload'),
                    // Removed mergePdfInput
                    backBtn: document.getElementById('backBtn'),
                    pdfTitle: document.getElementById('pdfTitle'),
                    pdfCategory: document.getElementById('pdfCategory'),
                    pageInput: document.getElementById('pageInput'),
                    goToPage: document.getElementById('goToPage'),
                    // Removed sharePdfViewerBtn
                    // Removed downloadBtn
                    prevPage: document.getElementById('prevPage'),
                    nextPage: document.getElementById('nextPage'),
                    pdfGrid: document.getElementById('pdfGrid'),
                    noResults: document.getElementById('noResults'),
                    totalDocs: document.getElementById('totalDocs'),
                    searchResults: document.getElementById('searchResults'),
                    pdfContainer: document.getElementById('pdfContainer'),
                    loadingSpinner: document.getElementById('loadingSpinner'),
                    pdfPages: document.getElementById('pdfPages'),
                    thumbnailContainer: document.getElementById('thumbnailContainer'),
                    pageModal: document.getElementById('pageModal'),
                    modalCanvas: document.getElementById('modalCanvas'),
                    closeModal: document.getElementById('closeModal'),
                    zoomIn: document.getElementById('zoomIn'),
                    zoomOut: document.getElementById('zoomOut'),
                    resetZoom: document.getElementById('resetZoom'),
                    openPresentationBtn: document.getElementById('openPresentationBtn'),
                    historyGrid: document.getElementById('historyGrid'),
                    noHistory: document.getElementById('noHistory'),
                    presentationModal: document.getElementById('presentationModal'),
                    presentationCanvas: document.getElementById('presentationCanvas'),
                    drawingCanvas: document.getElementById('drawingCanvas'),
                    prevPresentationPageBtn: document.getElementById('prevPresentationPageBtn'),
                    nextPresentationPageBtn: document.getElementById('nextPresentationPageBtn'),
                    closePresentationBtn: document.getElementById('closePresentationBtn'),
                    presentationThumbnailContainer: document.getElementById('presentationThumbnailContainer'),
                    toggleAutoplayBtn: document.getElementById('toggleAutoplayBtn'),
                    togglePointerBtn: document.getElementById('togglePointerBtn'),
                    togglePenBtn: document.getElementById('togglePenBtn'),
                    // Removed colorPickerContainer
                    // Removed colorSwatches
                    openCreatePdfModalBtn: document.getElementById('openCreatePdfModalBtn'),
                    createPdfScreen: document.getElementById('createPdfScreen'),
                    backToMainFromCreatePdfBtn: document.getElementById('backToMainFromCreatePdfBtn'),
                    imageUploadInput: document.getElementById('imageUploadInput'),
                    imagePreviews: document.getElementById('imagePreviews'),
                    noImageSelected: document.getElementById('noImageSelected'),
                    newPdfNameInput: document.getElementById('newPdfNameInput'),
                    newPdfPasswordInput: document.getElementById('newPdfPasswordInput'), // Still exists in HTML, but not used for locking
                    createPdfFromImagesBtn: document.getElementById('createPdfFromImagesBtn'),
                    cancelCreatePdfBtn: document.getElementById('cancelCreatePdfBtn'),
                    openScanToPdfScreenBtn: document.getElementById('openScanToPdfScreenBtn'),
                    scanToPdfScreen: document.getElementById('scanToPdfScreen'),
                    backToMainFromScanBtn: document.getElementById('backToMainFromScanBtn'),
                    videoFeed: document.getElementById('videoFeed'),
                    captureCanvas: document.getElementById('captureCanvas'),
                    flashOverlay: document.getElementById('flashOverlay'),
                    toggleFlashBtn: document.getElementById('toggleFlashBtn'),
                    switchCameraBtn: document.getElementById('switchCameraBtn'),
                    captureButton: document.getElementById('captureButton'),
                    imageCapturePreviews: document.getElementById('imageCapturePreviews'),
                    noCapturedImages: document.getElementById('noCapturedImages'),
                    createPdfFromScanBtn: document.getElementById('createPdfFromScanBtn'),
                    bottomNavBar: document.getElementById('bottomNavBar'),
                    navTools: document.getElementById('navTools'),
                    navFiles: document.getElementById('navFiles')
                };
                this.addDefaultPdf(); // Load default PDF on start
                this.initializeEventListeners();
                this.showToolsScreen();
            }
            initializeEventListeners() {
                this.elements.searchInput.addEventListener('input', (e) => this.handleSearch(e.target.value));
                this.elements.fileUpload.addEventListener('change', (e) => this.handleFileUpload(e));
                // Removed this.elements.mergePdfInput.addEventListener
                this.elements.backBtn.addEventListener('click', () => this.showActiveScreenBeforeViewer());
                this.elements.goToPage.addEventListener('click', () => this.goToPage());
                this.elements.pageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.goToPage();
                    }
                });
                // Removed this.elements.sharePdfViewerBtn.addEventListener
                // Removed this.elements.downloadBtn.addEventListener
                this.elements.prevPage.addEventListener('click', () => this.navigatePage(-1));
                this.elements.nextPage.addEventListener('click', () => this.navigatePage(1));
                this.elements.closeModal.addEventListener('click', () => this.closeModal());
                this.elements.zoomIn.addEventListener('click', () => this.adjustZoom(0.2));
                this.elements.zoomOut.addEventListener('click', () => this.adjustZoom(-0.2));
                this.elements.resetZoom.addEventListener('click', () => this.resetZoom());
                this.elements.openPresentationBtn.addEventListener('click', () => this.openPresentationMode());
                
                // Pen button logic (simplified)
                this.elements.togglePenBtn.addEventListener('click', this.togglePenMode.bind(this)); // Bound explicitly

                this.elements.prevPresentationPageBtn.addEventListener('click', () => {
                    this.stopAutoplay();
                    this.navigatePresentationPage(-1);
                });
                this.elements.nextPresentationPageBtn.addEventListener('click', () => {
                    this.stopAutoplay();
                    this.navigatePresentationPage(1);
                });
                this.elements.closePresentationBtn.addEventListener('click', () => this.closePresentationMode());
                this.elements.toggleAutoplayBtn.addEventListener('click', () => this.toggleAutoplay());
                this.elements.togglePointerBtn.addEventListener('click', () => this.togglePointerMode());
                
                this.elements.openCreatePdfModalBtn.addEventListener('click', () => this.openCreatePdfScreen());
                this.elements.backToMainFromCreatePdfBtn.addEventListener('click', () => this.showToolsScreen());
                this.elements.imageUploadInput.addEventListener('change', (e) => this.handleImageUpload(e));
                this.elements.createPdfFromImagesBtn.addEventListener('click', () => this.createPdfFromImages());
                this.elements.cancelCreatePdfBtn.addEventListener('click', () => this.closeCreatePdfScreen());
                
                // Fixed: Ensure openScanToPdfScreenBtn exists before adding listener
                if (this.elements.openScanToPdfScreenBtn) {
                    this.elements.openScanToPdfScreenBtn.addEventListener('click', this.openScanToPdfScreen); 
                } else {
                    console.error("Element openScanToPdfScreenBtn not found. Scan to PDF functionality may be impaired.");
                }

                this.elements.backToMainFromScanBtn.addEventListener('click', () => this.closeScanToPdfScreen());
                this.elements.toggleFlashBtn.addEventListener('click', this.toggleFlash); // No bind needed, now arrow function
                this.elements.switchCameraBtn.addEventListener('click', this.switchCamera); // No bind needed, now arrow function
                this.elements.captureButton.addEventListener('click', this.capturePhoto); // No bind needed, now arrow function
                this.elements.createPdfFromScanBtn.addEventListener('click', this.createPdfFromScannedImages); // No bind needed, now arrow function
                this.elements.navTools.addEventListener('click', () => this.showToolsScreen());
                this.elements.navFiles.addEventListener('click', () => this.showFilesScreen());
                document.addEventListener('keydown', (e) => this.handleKeyboard(e));
                this.elements.pdfContainer.addEventListener('scroll', () => this.updateCurrentPageOnScroll());
                this.elements.drawingCanvas.addEventListener('mousemove', (e) => this.handleDrawingMove(e));
                this.elements.drawingCanvas.addEventListener('touchmove', (e) => this.handleDrawingMove(e.touches[0]));
                this.elements.drawingCanvas.addEventListener('mousedown', (e) => this.handleDrawingStart(e));
                this.elements.drawingCanvas.addEventListener('touchstart', (e) => this.handleDrawingStart(e.touches[0]));
                this.elements.drawingCanvas.addEventListener('mouseup', (e) => this.handleDrawingEnd(e));
                this.elements.drawingCanvas.addEventListener('touchend', (e) => this.handleDrawingEnd(e.changedTouches[0]));
                this.elements.drawingCanvas.addEventListener('mouseleave', () => this.clearPointer());
                this.elements.drawingCanvas.addEventListener('touchcancel', () => this.clearPointer());
            }
            // Removed handleGlobalClick
            // Removed showColorPicker
            // Removed hideColorPicker
            handleKeyboard(e) {
                if ((e.metaKey || e.ctrlKey) && e.key === 'k' && !this.elements.filesScreen.classList.contains('hidden')) {
                    e.preventDefault();
                    this.elements.searchInput.focus();
                }
                if (this.elements.pdfViewer.classList.contains('hidden') &&
                    this.elements.createPdfScreen.classList.contains('hidden') &&
                    this.elements.scanToPdfScreen.classList.contains('hidden')) {
                    return;
                }
                if (!this.elements.presentationModal.classList.contains('hidden')) {
                    switch (e.key) {
                        case 'ArrowLeft':
                            this.stopAutoplay();
                            this.navigatePresentationPage(-1);
                            break;
                        case 'ArrowRight':
                            this.stopAutoplay();
                            this.navigatePresentationPage(1);
                            break;
                        case 'Escape':
                            this.closePresentationMode();
                            break;
                        case ' ':
                            e.preventDefault();
                            this.toggleAutoplay();
                            break;
                        case 'p':
                            this.togglePointerMode();
                            break;
                        case 'e':
                            this.togglePenMode();
                            break;
                    }
                    return;
                }
                switch (e.key) {
                    case 'ArrowLeft':
                        this.navigatePage(-1);
                        break;
                    case 'ArrowRight':
                        this.navigatePage(1);
                        break;
                    case 'Escape':
                        if (!this.elements.pageModal.classList.contains('hidden')) {
                            this.closeModal();
                        } else if (!this.elements.createPdfScreen.classList.contains('hidden')) {
                            this.closeCreatePdfScreen();
                        } else if (!this.elements.scanToPdfScreen.classList.contains('hidden')) {
                            this.closeScanToPdfScreen();
                        }
                        break;
                    case '+':
                        if (this.elements.pageModal.classList.contains('hidden')) return;
                        this.adjustZoom(0.2);
                        break;
                    case '-':
                        if (this.elements.pageModal.classList.contains('hidden')) return;
                        this.adjustZoom(-0.2);
                        break;
                    default:
                        break;
                }
            }
            // No local storage for pdfFiles or history
            addPdfToList(newPdf) {
                const existingIndex = this.pdfFiles.findIndex(p => p.id === newPdf.id);
                if (existingIndex > -1) {
                    this.pdfFiles[existingIndex] = { ...this.pdfFiles[existingIndex], ...newPdf };
                } else {
                    this.pdfFiles.push(newPdf);
                }
                this.handleSearch(this.elements.searchInput.value);
            }
            removePdfFromList(id) {
                this.pdfFiles = this.pdfFiles.filter(pdf => pdf.id !== id);
                this.handleSearch(this.elements.searchInput.value);
                this.notificationManager.showInfo('Document removed from library.');
            }
            addDefaultPdf() {
                const defaultPdf = {
                    id: 1,
                    name: 'Fmm class 10',
                    category: 'Education',
                    description: 'Financial Market Management for Class 10 (NSQF Level-2) by CBSE.',
                    data: null, // Data will be fetched on first open
                    pages: 0,
                    tags: ['finance', 'education', 'CBSE']
                };
                // Check if default PDF already exists in memory
                const existingDefaultPdf = this.pdfFiles.find(p => p.id === defaultPdf.id);
                if (!existingDefaultPdf) {
                    this.pdfFiles.push(defaultPdf);
                    this.notificationManager.showInfo('Default sample PDF added to library. It will load on first open.');
                }
            }
            // No local storage for history
            addPdfToHistory(file) {
                const historyItem = {
                    id: file.id,
                    name: file.name,
                    category: file.category,
                };
                this.openedPdfHistory = this.openedPdfHistory.filter(item => item.id !== historyItem.id);
                this.openedPdfHistory.unshift(historyItem);
                if (this.openedPdfHistory.length > 5) {
                    this.openedPdfHistory = this.openedPdfHistory.slice(0, 5);
                }
                this.renderHistory();
            }
            removeHistoryItem(id) {
                this.openedPdfHistory = this.openedPdfHistory.filter(item => item.id !== id);
                this.renderHistory();
                this.notificationManager.showInfo('PDF removed from history.');
            }
            handleFileUpload(e) {
                const file = e.target.files[0];
                if (file) {
                    if (file.type !== 'application/pdf') {
                        this.notificationManager.showError('Please upload a valid PDF file.');
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const arrayBuffer = event.target.result;
                            const fileName = file.name.replace(/\.pdf$/i, '');
                            const uploadedFile = {
                                id: Date.now(),
                                name: fileName,
                                category: 'Uploaded',
                                description: `User uploaded PDF: ${fileName}`,
                                data: new Uint8Array(arrayBuffer),
                                pages: 0,
                                tags: ['uploaded']
                            };
                            this.addPdfToList(uploadedFile);
                            this.openPdf(uploadedFile);
                        } catch (error) {
                            console.error('Error processing uploaded file:', error);
                            this.notificationManager.showError(`Failed to process uploaded PDF: ${error.message}`);
                        }
                    };
                    reader.onerror = () => {
                        this.notificationManager.showError('Failed to read file.');
                    };
                    reader.readAsArrayBuffer(file);
                    e.target.value = '';
                }
            }
            // Removed handleMergePdf
            handleSearch(query) {
                const searchLower = query.toLowerCase().trim();
                if (!searchLower) {
                    this.filteredFiles = [...this.pdfFiles];
                    this.renderPdfGrid();
                    return;
                }
                this.filteredFiles = this.pdfFiles.filter(file =>
                    file.name.toLowerCase().includes(searchLower) ||
                    file.category.toLowerCase().includes(searchLower) ||
                    file.description.toLowerCase().includes(searchLower) ||
                    (file.tags && file.tags.some(tag => tag.toLowerCase().includes(searchLower)))
                );
                this.renderPdfGrid();
            }
            hideAllScreens() {
                this.elements.toolsScreen.classList.add('hidden');
                this.elements.filesScreen.classList.add('hidden');
                this.elements.pdfViewer.classList.add('hidden');
                this.elements.createPdfScreen.classList.add('hidden');
                this.elements.scanToPdfScreen.classList.add('hidden');
                this.closePresentationMode();
                this.elements.mainHeader.classList.add('hide-on-non-main-screens');
                this.elements.bottomNavBar.classList.add('hide-on-non-main-screens');
            }
            showToolsScreen() {
                this.hideAllScreens();
                this.elements.toolsScreen.classList.remove('hidden');
                this.elements.navTools.classList.add('active');
                this.elements.navFiles.classList.remove('active');
                this.elements.mainHeader.classList.remove('hide-on-non-main-screens');
                this.elements.bottomNavBar.classList.remove('hide-on-non-main-screens');
            }
            showFilesScreen() {
                this.hideAllScreens();
                this.elements.filesScreen.classList.remove('hidden');
                this.elements.navFiles.classList.add('active');
                this.elements.navTools.classList.remove('active');
                this.handleSearch(this.elements.searchInput.value);
                this.renderHistory();
                this.elements.mainHeader.classList.remove('hide-on-non-main-screens');
                this.elements.bottomNavBar.classList.remove('hide-on-non-main-screens');
            }
            showActiveScreenBeforeViewer() {
                if (this.elements.navFiles.classList.contains('active')) {
                    this.showFilesScreen();
                } else {
                    this.showToolsScreen();
                }
                if (this.pdfDoc) {
                    this.pdfDoc.destroy();
                }
                this.pdfDoc = null;
                this.currentPdf = null;
                this.elements.pdfPages.innerHTML = '';
                this.elements.thumbnailContainer.innerHTML = '';
                this.pages = [];
                this.elements.loadingSpinner.classList.add('hidden');
            }
            showPdfViewer() {
                this.hideAllScreens();
                this.elements.pdfViewer.classList.remove('hidden');
            }
            openCreatePdfScreen() {
                this.hideAllScreens();
                this.elements.createPdfScreen.classList.remove('hidden');
                if (!this.imagesToPdf || this.imagesToPdf.length === 0) {
                     this.imagesToPdf = [];
                }
                this.renderImagePreviews();
                this.elements.newPdfNameInput.value = '';
            }
            closeCreatePdfScreen() {
                this.elements.createPdfScreen.classList.add('hidden');
                this.showToolsScreen();
                this.imagesToPdf = [];
                this.renderImagePreviews();
                this.elements.imageUploadInput.value = '';
            }
            downloadBytes(bytes, fileName, mimeType) {
                try {
                    const blob = new Blob([bytes], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    this.notificationManager.showSuccess(`Downloading "${fileName}"...`);
                } catch (error) {
                    console.error('Error initiating download:', error);
                    this.notificationManager.showError(`Failed to initiate download: ${error.message}.`);
                }
            }
            // Changed to arrow function property to ensure 'this' context
            openScanToPdfScreen = async () => {
                this.hideAllScreens();
                this.elements.scanToPdfScreen.classList.remove('hidden');
                this.capturedImages = [];
                this.renderCapturedImages();
                await this.startCamera();
            }
            closeScanToPdfScreen() {
                this.elements.scanToPdfScreen.classList.add('hidden');
                this.stopCamera();
                this.showToolsScreen();
            }
            startCamera = async () => { // Converted to arrow function
                this.notificationManager.showInfo('Requesting camera access...');
                try {
                    const constraints = {
                        video: {
                            facingMode: this.facingMode
                        }
                    };
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.elements.videoFeed.srcObject = stream;
                    this.cameraStream = stream;
                    this.elements.videoFeed.play();
                    this.notificationManager.showSuccess('Camera started.');
                } catch (err) {
                    console.error('Error accessing camera:', err);
                    if (err.name === 'NotAllowedError') {
                        this.notificationManager.showError('Camera access denied. Please allow camera permissions in your browser settings.');
                    } else if (err.name === 'NotFoundError') {
                        this.notificationManager.showError('No camera found on this device.');
                    } else {
                        this.notificationManager.showError(`Failed to start camera: ${err.message}`);
                    }
                }
            }
            stopCamera = () => { // Converted to arrow function
                if (this.cameraStream) {
                    this.cameraStream.getTracks().forEach(track => track.stop());
                    this.elements.videoFeed.srcObject = null;
                    this.cameraStream = null;
                    this.notificationManager.showInfo('Camera stopped.');
                }
            }
            toggleFlash = () => { // Converted to arrow function
                this.elements.flashOverlay.classList.toggle('active');
                const isActive = this.elements.flashOverlay.classList.contains('active');
                this.notificationManager.showInfo(`Flash: ${isActive ? 'On' : 'Off'}`);
            }
            switchCamera = async () => { // Converted to arrow function
                this.stopCamera();
                this.facingMode = (this.facingMode === 'environment') ? 'user' : 'environment';
                this.elements.videoFeed.style.transform = (this.facingMode === 'user') ? 'scaleX(-1)' : 'scaleX(1)';
                await this.startCamera();
                this.notificationManager.showInfo(`Switched to ${this.facingMode} camera.`);
            }
            capturePhoto = () => { // Converted to arrow function
                if (!this.elements.videoFeed.srcObject) {
                    this.notificationManager.show('Camera not active. Cannot capture photo.', 'warning');
                    return;
                }
                const video = this.elements.videoFeed;
                const canvas = this.elements.captureCanvas;
                const context = canvas.getContext('2d');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                const imageDataUrl = canvas.toDataURL('image/png');
                this.capturedImages.push({ dataUrl: imageDataUrl });
                this.renderCapturedImages();
                this.notificationManager.showSuccess('Photo captured!');
                this.elements.flashOverlay.classList.add('active');
                setTimeout(() => {
                    this.elements.flashOverlay.classList.remove('active');
                }, 100);
            }
            renderCapturedImages() {
                const container = this.elements.imageCapturePreviews;
                container.innerHTML = '';
                if (this.capturedImages.length === 0) {
                    this.elements.noCapturedImages.classList.remove('hidden');
                } else {
                    this.elements.noCapturedImages.classList.add('hidden');
                    this.capturedImages.forEach((image, index) => {
                        const item = document.createElement('div');
                        item.className = 'captured-image-item';
                        item.innerHTML = `
                            <span class="image-number">${index + 1}</span>
                            <img src="${image.dataUrl}" alt="Captured Image ${index + 1}">
                            <button class="remove-captured-image-btn" data-index="${index}"><i class="fas fa-times"></i></button>
                        `;
                        container.appendChild(item);
                    });
                    container.querySelectorAll('.remove-captured-image-btn').forEach(button => {
                        button.addEventListener('click', (e) => {
                            const indexToRemove = parseInt(e.currentTarget.dataset.index);
                            this.removeCapturedImage(indexToRemove);
                        });
                    });
                    container.scrollLeft = container.scrollWidth;
                }
            }
            removeCapturedImage(index) {
                this.capturedImages.splice(index, 1);
                this.renderCapturedImages();
                this.notificationManager.showInfo('Photo removed.');
            }
            createPdfFromScannedImages = async () => { // Converted to arrow function
                if (this.capturedImages.length === 0) {
                    this.notificationManager.show('Please capture some photos first to create a PDF.', 'warning');
                    return;
                }
                this.stopCamera();
                this.elements.scanToPdfScreen.classList.add('hidden');
                this.openCreatePdfScreen();
                this.imagesToPdf = this.capturedImages.map(img => ({
                    file: { type: 'image/png' },
                    dataUrl: img.dataUrl
                }));
                this.renderImagePreviews();
                this.notificationManager.showInfo('Captured photos loaded into "Create PDF" section. You can now name and create your PDF.');
            }
            renderPdfGrid() {
                const grid = this.elements.pdfGrid;
                const noResults = this.elements.noResults;
                const totalDocs = this.elements.totalDocs;
                const searchResults = this.elements.searchResults;
                grid.innerHTML = '';
                if (this.filteredFiles.length === 0) {
                    grid.classList.add('hidden');
                    noResults.classList.remove('hidden');
                    totalDocs.textContent = '0 documents';
                    searchResults.classList.remove('hidden');
                    searchResults.textContent = 'No results for your search.';
                    return;
                }
                grid.classList.remove('hidden');
                noResults.classList.add('hidden');
                totalDocs.textContent = `${this.filteredFiles.length} document${this.filteredFiles.length !== 1 ? 's' : ''}`;
                searchResults.classList.add('hidden');
                this.filteredFiles.forEach((file, index) => {
                    const card = document.createElement('div');
                    card.className = 'glass glass-hover card-float rounded-2xl p-6 cursor-pointer fade-in';
                    card.style.animationDelay = `${index * 0.1}s`;
                    const actionButtonHtml = ``; // Removed share button from card
                    card.innerHTML = `
                        <div class="flex items-start justify-between mb-4">
                            <div class="flex items-center space-x-3">
                                <div class="w-12 h-12 bg-gradient-to-r from-purple-500 to-pink-500 rounded-xl flex items-center justify-content-center flex-shrink-0">
                                    <i class="fas fa-file-pdf text-white text-lg"></i>
                                </div>
                                <div>
                                    <h3 class="text-lg font-semibold text-white mb-1">${file.name}</h3>
                                    <div class="category-badge">${file.category}</div>
                                </div>
                            </div>
                            <div class="text-gray-400 text-sm">${file.pages} pages</div>
                        </div>
                        <p class="text-gray-300 text-sm mb-4 line-clamp-2">${file.description}</p>
                        <div class="flex items-center justify-between">
                            <div class="flex flex-wrap gap-2">
                                ${file.tags.slice(0, 3).map(tag => `<span class="px-2 py-1 bg-gray-700 text-gray-300 text-xs rounded-full">${tag}</span>`).join('')}
                            </div>
                            ${actionButtonHtml}
                        </div>
                    `;
                    card.addEventListener('click', (e) => {
                        // No share button to check for, directly open PDF
                        this.openPdf(file);
                    });
                    grid.appendChild(card);
                });
                // Removed event listener for share-pdf-btn
            }
            renderHistory() {
                const historyGrid = this.elements.historyGrid;
                historyGrid.innerHTML = '';
                if (this.openedPdfHistory.length === 0) {
                    this.elements.noHistory.classList.remove('hidden');
                    return;
                }
                this.elements.noHistory.classList.add('hidden');
                this.openedPdfHistory.forEach((file, index) => {
                    const card = document.createElement('div');
                    card.className = 'glass glass-hover rounded-2xl p-4 cursor-pointer relative fade-in';
                    card.style.animationDelay = `${index * 0.05}s`;
                    const actionButtonHtml = ``; // Removed share button from history card
                    card.innerHTML = `
                        <div class="flex items-center space-x-3 pr-8">
                            <div class="w-10 h-10 bg-gradient-to-r from-blue-500 to-teal-500 rounded-lg flex items-center justify-content-center flex-shrink-0">
                                <i class="fas fa-file-pdf text-white text-md"></i>
                            </div>
                            <div class="flex-grow">
                                <h3 class="text-md font-semibold text-white truncate">${file.name}</h3>
                                <p class="text-gray-400 text-xs">${file.category}</p>
                            </div>
                            ${actionButtonHtml}
                        </div>
                    `;
                    card.addEventListener('click', (e) => {
                        // No share button to check for, directly open PDF
                        const foundFile = this.pdfFiles.find(p => p.id === file.id);
                        if (foundFile) {
                            this.openPdf(foundFile);
                        } else {
                            this.notificationManager.showError(`PDF "${file.name}" not found in library. It might have been removed.`);
                            this.removeHistoryItem(file.id);
                        }
                    });
                    historyGrid.appendChild(card);
                });
                // Removed event listener for share-history-btn
            }
            async openPdf(file) { // Removed password parameter
                const fullPdfObject = this.pdfFiles.find(p => p.id === file.id);
                if (!fullPdfObject) {
                    this.notificationManager.showError(`PDF "${file.name}" not found in library.`);
                    this.showActiveScreenBeforeViewer();
                    return;
                }
                this.currentPdf = { ...fullPdfObject };
                this.showPdfViewer();
                this.elements.pdfTitle.textContent = this.currentPdf.name;
                this.elements.pdfCategory.textContent = this.currentPdf.category;
                this.elements.loadingSpinner.classList.remove('hidden');
                if (this.pdfDoc) {
                    this.pdfDoc.destroy();
                }
                this.pdfDoc = null;
                this.elements.pdfPages.innerHTML = '';
                this.elements.thumbnailContainer.innerHTML = '';
                this.pages = [];
                try {
                    let pdfDataBytes = this.currentPdf.data;
                    if (!(pdfDataBytes instanceof Uint8Array) || pdfDataBytes.length === 0) {
                        if (this.currentPdf.id === 1 && this.currentPdf.name === 'Fmm class 10') {
                            this.notificationManager.showInfo('Fetching default PDF...');
                            const response = await fetch('https://arlabs07.github.io/Arhub07.github.io/App/file1.pdf');
                            if (!response.ok) {
                                throw new Error(`Network response was not ok: ${response.statusText}`);
                            }
                            pdfDataBytes = new Uint8Array(await response.arrayBuffer());
                            this.currentPdf.data = pdfDataBytes;
                            // Update the pdfFiles entry with data for the default PDF (in-memory)
                            const pdfIndex = this.pdfFiles.findIndex(p => p.id === this.currentPdf.id);
                            if (pdfIndex !== -1) {
                                this.pdfFiles[pdfIndex].data = pdfDataBytes;
                            }
                        } else {
                            throw new Error(`PDF content for "${this.currentPdf.name}" is not available. Please re-upload this file to view it.`);
                        }
                    }
                    const pdfLoadingTask = pdfjsLib.getDocument({
                        data: pdfDataBytes
                    });
                    this.pdfDoc = await pdfLoadingTask.promise;
                    this.totalPages = this.pdfDoc.numPages;
                    this.currentPage = 1;
                    this.elements.pageInput.max = this.totalPages;
                    this.elements.pageInput.value = 1;
                    
                    // Update page count in pdfFiles metadata (in-memory)
                    const pdfIndex = this.pdfFiles.findIndex(p => p.id === this.currentPdf.id);
                    if (pdfIndex !== -1) {
                        this.pdfFiles[pdfIndex].pages = this.totalPages;
                    }
                    
                    await this.renderAllPages(this.pdfDoc);
                    await this.renderThumbnails(this.pdfDoc);
                    this.elements.loadingSpinner.classList.add('hidden');
                    this.updateThumbnailSelection();
                    this.notificationManager.showSuccess(`"${this.currentPdf.name}" loaded successfully.`);
                    this.addPdfToHistory(this.currentPdf);
                } catch (error) {
                    console.error('Error loading PDF:', error);
                    this.elements.loadingSpinner.classList.add('hidden');
                    if (this.pdfDoc) {
                        this.pdfDoc.destroy();
                    }
                    this.pdfDoc = null;
                    this.currentPdf = null;
                    if (error.name === 'PasswordException') {
                        this.notificationManager.showError('This PDF is password protected and cannot be opened.');
                    } else {
                        this.notificationManager.showError(`Failed to load PDF: "${file.name}". Error: ${error.message}.`);
                    }
                    this.showActiveScreenBeforeViewer();
                }
            }
            async renderAllPages(pdf) {
                const container = this.elements.pdfPages;
                container.innerHTML = '';
                this.pages = [];
                const containerWidth = this.elements.pdfContainer.clientWidth;
                const qualityScaleFactor = 1.5;
                for (let pageNum = 1; pageNum <= this.totalPages; pageNum++) {
                    try {
                        const page = await pdf.getPage(pageNum);
                        const defaultViewport = page.getViewport({ scale: 1 });
                        const baseScale = containerWidth / defaultViewport.width;
                        const finalScale = baseScale * qualityScaleFactor;
                        const viewport = page.getViewport({ scale: finalScale });
                        const canvas = document.createElement('canvas');
                        canvas.className = 'page-canvas rounded-lg shadow-lg mb-6';
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        const context = canvas.getContext('2d');
                        await page.render({ canvasContext: context, viewport: viewport }).promise;
                        canvas.addEventListener('click', () => this.openPageModal(page, pageNum));
                        container.appendChild(canvas);
                        this.pages.push({ canvas, page, pageNum });
                    } catch (pageError) {
                        console.error(`Error rendering page ${pageNum}:`, pageError);
                        this.notificationManager.show(`Could not render page ${pageNum}. Skipping.`, 'warning');
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'w-full h-48 bg-gray-800 text-gray-500 flex items-center justify-center rounded-lg';
                        errorDiv.textContent = `Error loading page ${pageNum}`;
                        container.appendChild(errorDiv);
                    }
                }
            }
            async renderThumbnails(pdf) {
                const container = this.elements.thumbnailContainer;
                container.innerHTML = '';
                for (let pageNum = 1; pageNum <= this.totalPages; pageNum++) {
                    try {
                        const page = await pdf.getPage(pageNum);
                        const viewport = page.getViewport({ scale: 0.25 });
                        const canvas = document.createElement('canvas');
                        canvas.className = 'thumbnail w-16 h-20 rounded cursor-pointer flex-shrink-0';
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        const context = canvas.getContext('2d');
                        await page.render({ canvasContext: context, viewport: viewport }).promise;
                        const wrapper = document.createElement('div');
                        wrapper.className = 'flex flex-col items-center space-y-1';
                        wrapper.innerHTML = `<span class="text-xs text-gray-400">${pageNum}</span>`;
                        wrapper.insertBefore(canvas, wrapper.firstChild);
                        canvas.addEventListener('click', () => this.scrollToPage(pageNum));
                        container.appendChild(wrapper);
                    } catch (thumbError) {
                        console.error(`Error rendering thumbnail for page ${pageNum}:`, thumbError);
                        this.notificationManager.show(`Could not render thumbnail for page ${pageNum}.`, 'warning');
                    }
                }
            }
            scrollToPage(pageNum) {
                if (pageNum < 1 || pageNum > this.totalPages || !this.pages[pageNum - 1]) {
                    this.notificationManager.showError(`Page ${pageNum} does not exist.`);
                    return;
                }
                const pageElement = this.pages[pageNum - 1]?.canvas;
                if (pageElement) {
                    pageElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    this.currentPage = pageNum;
                    this.elements.pageInput.value = pageNum;
                    this.updateThumbnailSelection();
                } else {
                    this.notificationManager.showError(`Could not find element for page ${pageNum}.`);
                }
            }
            updateThumbnailSelection() {
                const thumbnails = document.querySelectorAll('.thumbnail');
                thumbnails.forEach((thumb, index) => {
                    thumb.classList.toggle('active', index + 1 === this.currentPage);
                });
                const activeThumbnail = document.querySelector('.thumbnail.active');
                if (activeThumbnail) {
                    activeThumbnail.scrollIntoView({ behavior: 'smooth', inline: 'center' });
                }
            }
            updateCurrentPageOnScroll() {
                const container = this.elements.pdfContainer;
                const pages = this.elements.pdfPages.children;
                let newCurrentPage = this.currentPage;
                for (let i = 0; i < pages.length; i++) {
                    const pageElement = pages[i];
                    const rect = pageElement.getBoundingClientRect();
                    if (rect.top >= 0 && rect.top < container.clientHeight / 2) {
                        newCurrentPage = i + 1;
                        break;
                    }
                }
                if (newCurrentPage !== this.currentPage) {
                    this.currentPage = newCurrentPage;
                    this.elements.pageInput.value = this.currentPage;
                    this.updateThumbnailSelection();
                }
            }
            async openPageModal(page, pageNum) {
                this.elements.pageModal.classList.remove('hidden');
                this.elements.pageModal.classList.add('slide-up');
                this.zoomLevel = 1;
                this.currentPage = pageNum;
                await this.renderModalPage(page, this.elements.modalCanvas);
            }
            async renderModalPage(page, canvas) {
                try {
                    const baseScale = 3.0;
                    const viewport = page.getViewport({ scale: this.zoomLevel * baseScale });
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    const context = canvas.getContext('2d');
                    await page.render({ canvasContext: context, viewport: viewport }).promise;
                } catch (error) {
                    console.error('Error rendering modal page:', error);
                    this.notificationManager.showError('Failed to render page in modal view.');
                }
            }
            closeModal() {
                this.elements.pageModal.classList.add('hidden');
                this.elements.pageModal.classList.remove('slide-up');
                this.zoomLevel = 1;
            }
            adjustZoom(delta) {
                const newZoom = Math.max(0.5, Math.min(3, this.zoomLevel + delta));
                if (newZoom !== this.zoomLevel) {
                    this.zoomLevel = newZoom;
                    const currentPageData = this.pages[this.currentPage - 1];
                    if (currentPageData && currentPageData.page) {
                        this.renderModalPage(currentPageData.page, this.elements.modalCanvas);
                    } else {
                        this.notificationManager.showError('Cannot adjust zoom: current page data is unavailable.');
                    }
                }
            }
            resetZoom() {
                this.zoomLevel = 1;
                const currentPageData = this.pages[this.currentPage - 1];
                if (currentPageData && currentPageData.page) {
                    this.renderModalPage(currentPageData.page, this.elements.modalCanvas);
                } else {
                    this.notificationManager.showError('Cannot reset zoom: current page data is unavailable.');
                }
            }
            goToPage() {
                const pageNumStr = this.elements.pageInput.value;
                const pageNum = parseInt(pageNumStr, 10);
                if (isNaN(pageNum) || pageNum < 1 || pageNum > this.totalPages) {
                    this.notificationManager.show(`Please enter a valid page number between 1 and ${this.totalPages}.`, 'warning');
                    this.elements.pageInput.value = this.currentPage;
                    return;
                }
                this.scrollToPage(pageNum);
            }
            navigatePage(direction) {
                const newPage = this.currentPage + direction;
                if (newPage >= 1 && newPage <= this.totalPages) {
                    this.scrollToPage(newPage);
                } else {
                    this.notificationManager.showInfo('You are at the beginning or end of the document.');
                }
            }
            async openPresentationMode() {
                if (!this.pdfDoc) {
                    this.notificationManager.show('No PDF is loaded to start presentation.', 'warning');
                    return;
                }
                this.elements.presentationModal.classList.remove('hidden');
                this.currentPresentationPage = this.currentPage;
                window.addEventListener('resize', this.resizeDrawingCanvas.bind(this));
                await this.renderPresentationPage(this.currentPresentationPage);
                this.resizeDrawingCanvas();
                await this.renderPresentationThumbnails();
                this.updatePresentationNavButtons();
                this.updatePresentationThumbnailSelection();
                this.stopAutoplay();
                this.isPointerActive = false;
                this.isPenActive = false;
                this.isDrawing = false;
                this.currentStroke = [];
                this.allPageDrawings.clear();
                this.clearDrawingCanvas();
            }
            resizeDrawingCanvas() {
                const pdfCanvas = this.elements.presentationCanvas;
                const drawingCanvas = this.elements.drawingCanvas;
                drawingCanvas.width = pdfCanvas.width;
                drawingCanvas.height = pdfCanvas.height;
                if (this.isPenActive) {
                    this.redrawCurrentPageDrawings();
                }
            }
            clearDrawingCanvas() {
                const ctx = this.elements.drawingCanvas.getContext('2d');
                ctx.clearRect(0, 0, this.elements.drawingCanvas.width, this.elements.drawingCanvas.height);
            }
            closePresentationMode() {
                this.elements.presentationModal.classList.add('hidden');
                this.stopAutoplay();
                const pdfCtx = this.elements.presentationCanvas.getContext('2d');
                pdfCtx.clearRect(0, 0, this.elements.presentationCanvas.width, this.elements.presentationCanvas.height);
                this.clearDrawingCanvas();
                this.allPageDrawings.clear();
                this.currentStroke = [];
                this.isDrawing = false;
                this.isPointerActive = false;
                this.isPenActive = false;
                this.penColorIndex = -1; // Reset pen color index
                window.removeEventListener('resize', this.resizeDrawingCanvas.bind(this));
            }
            async renderPresentationPage(pageNum) {
                if (!this.pdfDoc) {
                    console.error("pdfDoc is null, cannot render presentation page.");
                    this.notificationManager.showError("PDF document not available for presentation.");
                    return;
                }
                try {
                    const page = await this.pdfDoc.getPage(pageNum);
                    const canvas = this.elements.presentationCanvas;
                    const context = canvas.getContext('2d');
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    const qualityScale = 2.0;
                    const viewport = page.getViewport({ scale: qualityScale });
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    await page.render({ canvasContext: context, viewport: viewport }).promise;
                    this.currentPresentationPage = pageNum;
                    this.updatePresentationNavButtons();
                    this.updatePresentationThumbnailSelection();
                    this.resizeDrawingCanvas();
                    this.clearDrawingCanvas();
                    this.redrawCurrentPageDrawings();
                } catch (error) {
                    console.error(`Error rendering presentation page ${pageNum}:`, error);
                    this.notificationManager.showError(`Failed to render presentation page ${pageNum}.`);
                }
            }
            navigatePresentationPage(direction) {
                const newPage = this.currentPresentationPage + direction;
                if (newPage >= 1 && newPage <= this.totalPages) {
                    this.renderPresentationPage(newPage);
                } else {
                    this.notificationManager.showInfo('You are at the beginning or end of the document.');
                    this.stopAutoplay();
                }
            }
            updatePresentationNavButtons() {
                this.elements.prevPresentationPageBtn.disabled = (this.currentPresentationPage === 1);
                this.elements.nextPresentationPageBtn.disabled = (this.currentPresentationPage === this.totalPages);
                this.elements.prevPresentationPageBtn.classList.toggle('opacity-50', this.currentPresentationPage === 1);
                this.elements.nextPresentationPageBtn.classList.toggle('opacity-50', this.currentPresentationPage === this.totalPages);
                this.elements.prevPresentationPageBtn.style.cursor = (this.currentPresentationPage === 1) ? 'not-allowed' : 'pointer';
                this.elements.nextPresentationPageBtn.style.cursor = (this.currentPresentationPage === this.totalPages) ? 'not-allowed' : 'pointer';
            }
            async renderPresentationThumbnails() {
                const container = this.elements.presentationThumbnailContainer;
                container.innerHTML = '';
                if (!this.pdfDoc) {
                    console.error("pdfDoc is null, cannot render presentation thumbnails.");
                    this.notificationManager.showError("PDF document not available for thumbnail rendering.");
                    return;
                }
                for (let pageNum = 1; pageNum <= this.totalPages; pageNum++) {
                    try {
                        const page = await this.pdfDoc.getPage(pageNum);
                        const viewport = page.getViewport({ scale: 0.15 });
                        const canvas = document.createElement('canvas');
                        canvas.className = 'presentation-thumbnail rounded';
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        const context = canvas.getContext('2d');
                        await page.render({ canvasContext: context, viewport: viewport }).promise;
                        const wrapper = document.createElement('div');
                        wrapper.className = 'flex flex-col items-center space-y-1';
                        wrapper.innerHTML = `<span class="text-xs text-gray-400">${pageNum}</span>`;
                        wrapper.insertBefore(canvas, wrapper.firstChild);
                        canvas.addEventListener('click', () => {
                            this.stopAutoplay();
                            this.renderPresentationPage(pageNum);
                        });
                        container.appendChild(wrapper);
                    } catch (thumbError) {
                        console.error(`Error rendering presentation thumbnail for page ${pageNum}:`, thumbError);
                    }
                }
            }
            updatePresentationThumbnailSelection() {
                const thumbnails = this.elements.presentationThumbnailContainer.querySelectorAll('.presentation-thumbnail');
                thumbnails.forEach((thumb, index) => {
                    thumb.classList.toggle('active', index + 1 === this.currentPresentationPage);
                });
                const activeThumbnail = this.elements.presentationThumbnailContainer.querySelector('.presentation-thumbnail.active');
                if (activeThumbnail) {
                    activeThumbnail.scrollIntoView({ behavior: 'smooth', inline: 'center' });
                }
            }
            toggleAutoplay() {
                if (this.autoplayIntervalId) {
                    this.stopAutoplay();
                    this.notificationManager.showInfo('Autoplay paused.');
                } else {
                    this.startAutoplay();
                    this.notificationManager.showInfo('Autoplay started.');
                }
            }
            startAutoplay() {
                if (this.autoplayIntervalId) return;
                this.elements.toggleAutoplayBtn.innerHTML = '<i class="fas fa-pause"></i>';
                this.autoplayIntervalId = setInterval(() => {
                    if (this.currentPresentationPage < this.totalPages) {
                        this.navigatePresentationPage(1);
                    } else {
                        this.stopAutoplay();
                        this.notificationManager.showInfo('Autoplay finished.');
                    }
                }, 3000);
            }
            stopAutoplay() {
                if (!this.autoplayIntervalId) return;
                clearInterval(this.autoplayIntervalId);
                this.autoplayIntervalId = null;
                this.elements.toggleAutoplayBtn.innerHTML = '<i class="fas fa-play"></i>';
            }
            togglePointerMode() {
                this.isPointerActive = !this.isPointerActive;
                this.isPenActive = false; // Turn off pen mode if pointer is activated
                this.isDrawing = false;
                this.penColorIndex = -1; // Reset pen color index
                this.elements.togglePointerBtn.classList.toggle('bg-blue-600', this.isPointerActive);
                this.elements.togglePenBtn.classList.remove('bg-blue-600');
                this.clearDrawingCanvas();
                this.currentStroke = [];
                this.redrawCurrentPageDrawings();
                this.elements.drawingCanvas.style.cursor = this.isPointerActive ? 'none' : '';
                this.notificationManager.showInfo(`Pointer mode: ${this.isPointerActive ? 'On' : 'Off'}`);
            }
            togglePenMode() {
                this.isPointerActive = false; // Turn off pointer mode
                this.elements.togglePointerBtn.classList.remove('bg-blue-600');

                this.penColorIndex++; // Increment index for next color
                
                if (this.penColorIndex < this.penColors.length) {
                    this.isPenActive = true;
                    this.penColor = this.penColors[this.penColorIndex];
                    this.elements.togglePenBtn.classList.add('bg-blue-600');
                    this.elements.drawingCanvas.style.cursor = 'crosshair';
                    this.notificationManager.showInfo(`Pen mode: On, Color: ${this.penColor}`);
                } else {
                    // Cycle complete, turn off pen mode
                    this.isPenActive = false;
                    this.penColorIndex = -1; // Reset for next activation
                    this.elements.togglePenBtn.classList.remove('bg-blue-600');
                    this.elements.drawingCanvas.style.cursor = '';
                    this.clearDrawingCanvas();
                    this.allPageDrawings.clear(); // Clear all drawings when pen mode is turned off
                    this.notificationManager.showInfo('Pen mode: Off');
                }
                this.isDrawing = false; // Reset drawing state
                this.currentStroke = []; // Clear current stroke
                this.redrawCurrentPageDrawings(); // Redraw with new state
            }
            getScaledCoordinates(e) {
                const rect = this.elements.drawingCanvas.getBoundingClientRect();
                const canvas = this.elements.drawingCanvas;
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                return { x, y };
            }
            handleDrawingMove(e) {
                const { x, y } = this.getScaledCoordinates(e);
                this.clearDrawingCanvas();
                if (this.isPointerActive) {
                    this.drawPointer(x, y);
                }
                if (this.isPenActive && this.isDrawing) {
                    this.currentStroke.push({ x, y });
                    this.redrawCurrentPageDrawings();
                } else if (this.isPenActive) {
                    this.redrawCurrentPageDrawings();
                }
            }
            handleDrawingStart(e) {
                if (this.isPenActive) {
                    this.isDrawing = true;
                    const { x, y } = this.getScaledCoordinates(e);
                    this.currentStroke = [{ x, y }];
                }
            }
            handleDrawingEnd(e) {
                if (this.isPenActive && this.isDrawing) {
                    this.isDrawing = false;
                    if (this.currentStroke.length > 1) {
                        const pageDrawings = this.allPageDrawings.get(this.currentPresentationPage) || [];
                        pageDrawings.push({ stroke: this.currentStroke, color: this.penColor });
                        this.allPageDrawings.set(this.currentPresentationPage, pageDrawings);
                    }
                    this.currentStroke = [];
                }
                this.clearPointer();
            }
            drawPointer(x, y) {
                const ctx = this.elements.drawingCanvas.getContext('2d');
                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2);
                ctx.fill();
            }
            clearPointer() {
                if (!this.isPenActive) {
                    this.clearDrawingCanvas();
                } else {
                    this.redrawCurrentPageDrawings();
                }
            }
            redrawCurrentPageDrawings() {
                const ctx = this.elements.drawingCanvas.getContext('2d');
                this.clearDrawingCanvas();
                const drawings = this.allPageDrawings.get(this.currentPresentationPage) || [];
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                drawings.forEach(drawing => {
                    ctx.strokeStyle = drawing.color;
                    ctx.beginPath();
                    ctx.moveTo(drawing.stroke[0].x, drawing.stroke[0].y);
                    for (let i = 1; i < drawing.stroke.length; i++) {
                        ctx.lineTo(drawing.stroke[i].x, drawing.stroke[i].y);
                    }
                    ctx.stroke();
                });
                if (this.isDrawing && this.currentStroke.length > 0) {
                    ctx.strokeStyle = this.penColor;
                    ctx.beginPath();
                    ctx.moveTo(this.currentStroke[0].x, this.currentStroke[0].y);
                    for (let i = 1; i < this.currentStroke.length; i++) {
                        ctx.lineTo(this.currentStroke[i].x, this.currentStroke[i].y);
                    }
                    ctx.stroke();
                }
            }
            // Removed sharePdf
            // Removed downloadPdf
            handleImageUpload(e) {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;
                files.forEach(file => {
                    if (!file.type.startsWith('image/')) {
                        this.notificationManager.show(`Skipping non-image file: ${file.name}`, 'warning');
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        this.imagesToPdf.push({ file: file, dataUrl: event.target.result });
                        this.renderImagePreviews();
                    };
                    reader.onerror = () => {
                        this.notificationManager.showError(`Failed to read image: ${file.name}`);
                    };
                    reader.readAsDataURL(file);
                });
                e.target.value = '';
            }
            renderImagePreviews() {
                const container = this.elements.imagePreviews;
                container.innerHTML = '';
                if (this.imagesToPdf.length === 0) {
                    this.elements.noImageSelected.classList.remove('hidden');
                } else {
                    this.elements.noImageSelected.classList.add('hidden');
                    this.imagesToPdf.forEach((image, index) => {
                        const previewItem = document.createElement('div');
                        previewItem.className = 'image-preview-item';
                        previewItem.innerHTML = `
                            <span class="image-number">${index + 1}</span>
                            <img src="${image.dataUrl}" alt="${image.file ? image.file.name : `Image ${index + 1}`}">
                            <button class="remove-image-btn" data-index="${index}"><i class="fas fa-times"></i></button>
                        `;
                        container.appendChild(previewItem);
                    });
                    container.querySelectorAll('.remove-image-btn').forEach(button => {
                        button.addEventListener('click', (e) => {
                            const indexToRemove = parseInt(e.currentTarget.dataset.index);
                            this.removeImageForPdfCreation(indexToRemove);
                        });
                    });
                }
            }
            removeImageForPdfCreation(index) {
                this.imagesToPdf.splice(index, 1);
                this.renderImagePreviews();
                this.notificationManager.showInfo('Image removed.');
            }
            async createPdfFromImages() {
                if (this.imagesToPdf.length === 0) {
                    this.notificationManager.show('Please add images to create a PDF.', 'warning');
                    return;
                }
                const pdfName = this.elements.newPdfNameInput.value.trim() || 'Untitled Document';
                this.notificationManager.showInfo('Creating PDF from images...');
                try {
                    const pdfDoc = await PDFDocument.create();
                    for (const imgData of this.imagesToPdf) {
                        let image;
                        const imgBytes = new Uint8Array(await fetch(imgData.dataUrl).then(res => res.arrayBuffer()));
                        const imageType = imgData.file && imgData.file.type ? imgData.file.type : 'image/png';
                        if (imageType === 'image/jpeg') {
                            image = await pdfDoc.embedJpg(imgBytes);
                        } else if (imageType === 'image/png') {
                            image = await pdfDoc.embedPng(imgBytes);
                        } else if (imageType === 'image/webp') {
                            image = await pdfDoc.embedWebp(imgBytes);
                        } else {
                            this.notificationManager.show(`Unsupported image type: ${imageType}. Skipping.`, 'warning');
                            continue;
                        }
                        const page = pdfDoc.addPage();
                        const { width, height } = page.getSize();
                        const imgWidth = image.width;
                        const imgHeight = image.height;
                        const scale = Math.min(width / imgWidth, height / imgHeight);
                        const scaledWidth = imgWidth * scale;
                        const scaledHeight = imgHeight * scale;
                        const x = (width - scaledWidth) / 2;
                        const y = (height - scaledHeight) / 2;
                        page.drawImage(image, {
                            x: x,
                            y: y,
                            width: scaledWidth,
                            height: scaledHeight,
                        });
                    }
                    let pdfBytes = await pdfDoc.save();
                    
                    // Automatically download the created PDF
                    this.downloadBytes(pdfBytes, `${pdfName}.pdf`, 'application/pdf');

                    this.closeCreatePdfScreen();
                    const createdPdfFile = {
                        id: Date.now(),
                        name: pdfName,
                        category: 'Created',
                        description: `User created PDF: ${pdfName}`,
                        data: pdfBytes,
                        pages: pdfDoc.getPageCount(),
                        tags: ['created', 'images']
                    };
                    this.addPdfToList(createdPdfFile);
                    this.openPdf(createdPdfFile);
                } catch (error) {
                    console.error('Error creating PDF from images:', error);
                    this.notificationManager.showError(`Failed to create PDF from images: ${error.message}. Please try again.`);
                }
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            new PageFlow();
        });
    </script>
</body>
</html>
